---
title: "Develop TAZ/Census Equivalency Table"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

Our goal will be to produce an equivalence table relating year 2010 Bay Area Census Tracts to MTC's Transportation Analysis Zones (TAZ).

## Packages

Mapview is only required if you want to render maps.

dplyr, readr, and sf are required by the analysis but sf could probably be removed if necessary.

```{r, message=FALSE, warning=FALSE, results='hide'}
library(sf)
library(dplyr)
library(readr)
library(mapview)
```

## Data

Please see the data processing doc (`data_prep.Rmd`) for background on data sources and calculated variables. 

```{r, message=FALSE, warning=FALSE, results='hide'}
setwd("~/Box/DataViz\ Projects/Data\ Analysis\ and\ Visualization/census_examples/taz_tract/data")
tracts <- st_read("tracts.gpkg")
taz1454 <- st_read("taz1454.gpkg")

intersection_df <- st_read("intersection_df.gpkg")
intersection_df$probably_a_sliver <- as.logical(intersection_df$probably_a_sliver) 
intersection_df$definitely_a_sliver <- as.logical(intersection_df$definitely_a_sliver)

#blocks <- st_read("blocks.gpkg")
Tract_zone_2000 <- read_csv("Tract_zone_2000.csv")
year_2000_intersection_df <- st_read("intersection_df_2000.gpkg")
```

## Methods

### Throw out Topology Errors

There are a number of topology errors in the TAZ data. We threw these out in data processing. 

### Define Equivalence 

Equivalence is a misnomer. 

The relationships, in terms of aereas, are not equivalent. The kind of equivalence in area varies across rows, so the way that one tract is equivalent to a TAZ is not the same as the way another tract is equivalent to a TAZ. 

It seems that for modeling, there is an understanding of "equivalence" but the meaning of that is not stated and it doesn't realy mean anything in terms of geospatial equivalence. 

For example, tracts can be smaller than a TAZ and TAZ's can be smaller than a tract. 

In some cases, a tract is called "equivalent" to a tract when it is 1/20th the size of that TAZ. In other cases, a TAZ is called "equivalent" to a Tract when it is 1/20th the size of that Tract. 

### Define the Goal of the Lookup Table

From review of the year 2000 lookup table, we've defined the goal of this table: 

For any given Tract look up, either: 
(a) the TAZ that fully and completely circumscribes it, 
(b) that mostly circumscribes it, or finally, 
(c) the set of TAZ's that are within it. 

We have a rough idea of how many intersections we should expect to fall in each category by looking at the year 2000 CSV. 

```{r}
tract_zone_2000_dense <- reshape2::melt(Tract_zone_2000, id.vars = "Tract", na.rm=TRUE)

number_of_equivalencies <- group_by(tract_zone_2000_dense, variable) %>%
  summarize(count = n())

total <- sum(number_of_equivalencies$count)

number_of_equivalencies$percent <- round(number_of_equivalencies$count/total, digits=3)

print(number_of_equivalencies)
```

### Define further Potential Goals of the Lookup Table

The inverse might also be true. We expect that every TAZ should have a tract. 

If it is true, then we shuold also know how to: for any given TAZ the user would also like to look up the: (d) Tracts that are completely within it, (e) Tract that is mostly within it, or (f) the Tract that completely circumscribes it. 

For the purposes of this document we will ignore those questions (d,e,f) insofar as we can. 

## Identifying meaningful TAZ/Tract Spatial Relationships

The easiest way to approach this problem is to do a full spatial intersection on the two lookup tables, throw out the intersections that are simply due to topological errors in the data, then build the lookup table by identifying valid relationships of the type (a), (b), or (c), as described above. 

#### Build the 2010 Equivalence Table

The fastest way to do this is to only build the equivalence for new tracts, assuming the 2000 table is correct.

##### Update Year 2000 Table

In practice, there is at least one error in the 2000 lookup table that we will want to update. 

The second taz (rtaz) for tract 500300 is incorrect it should. be mapped to TAZ 539 but was mapped to TAZ 529. More details at the bottom here:  https://bayareametro.github.io/Data-And-Visualization-Projects/census_examples/taz_tract/reverse_engineer_tract_zone_2000_method.html

We'll fix that here since we will use the 2000 data as a basis for 2010. 

```{r}
print(Tract_zone_2000[Tract_zone_2000$Tract=="500300",'rtaz2'])
Tract_zone_2000[Tract_zone_2000$Tract=="500300",'rtaz2']=539
print(Tract_zone_2000[Tract_zone_2000$Tract=="500300",'rtaz2'])
```

Now we'll just build relationships for the new tracts in order to understand how we're building this table. 

'rtaz' is a column header from the year 2000 lookup table. If its not on the tract, then the tract hasn't already been mapped to a TAZ. 

```{r}
new_tracts <- tracts[is.na(tracts$rtaz1),]
new_tract_ids <- new_tracts$tract
length(new_tract_ids)
```

So we have 387 new tracts in 2010.  

#### Substantial Matches  

How do we decide which TAZ to match with which tract?

We need to decide which intersections are substantial. As we stated at the beginning, a substantial TAZ/Tract relationship can be one of the following:

For any given Tract: 
(a) the TAZ that fully and completely circumscribes it, 
(b) that mostly circumscribes it, or finally, 
(c) the set of TAZ's that are within it. 

Its easiest identify substantial relationships by process of elimination on the full spatial intersection of the data. 

So first we will drop the "probably a sliver" spatial relationships. This includes "definitely a sliver" relationships. These are not relationships that fall in any of the above categories. 

```{r, message=FALSE, warning=FALSE}
intersection_df_no_sliver <- intersection_df[!intersection_df$probably_a_sliver==TRUE,]
intersection_df_no_sliver <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% new_tract_ids,]
dim(intersection_df_no_sliver)
```

That leaves us with about 500 relationships for for 300 tracts. 

Lets first identify all tracts in sets (a) and (b) 

These tracts should have an area of intersection with a TAZ which is at least as large (within error) as the TAZ. 

We say "within error" because the topology errors here make full identity unlikely.

Ideally, the Tract's area of intersection with the TAZ would be identical to the TAZ's area (or greater). But because of topological errors, this rarely occurs. So we have to decide what cutoff we want to say is "within error."

Below we set it to conditions where the Tract's area of intersection with the TAZ is at least 70% of the area of the TAZ. 

We can compare this to the ratio of single-taz intersections (types (a) and (b)) in the year 2000 data. 

```{r}
intersection_df_no_sliver$intersection_area_over_tract_area <- as.numeric(intersection_df_no_sliver$intersection_area)/as.numeric(intersection_df_no_sliver$tract_area) 
summary(intersection_df_no_sliver$intersection_area_over_tract_area)
print(table(intersection_df_no_sliver$intersection_area_over_tract_area>.70))
```

If we base our decision on what on 2000 data then we should expect about 96% of the Tracts to map to only 1 TAZ, which again would be the relationship conditions defined as (a) and (b).

At 70% of intersection we get 363/387 or 93% of the intersections in the new Tracts being single-taz intersections. 

This seems about right, and a bit conservative. 

Interestingly, setting the intersection_area_over_tract_area ratio to 50% gets us to almost exactly 96%, which is what the year 2000 data had. But lets be conservative and go with 70%

Lets call those intersections acceptable, and put them in their own data frame.

```{r}
intersection_type_a_b <- intersection_df_no_sliver[intersection_df_no_sliver$intersection_area_over_tract_area>.70,]

tracts_left_id <- intersection_df_no_sliver[!intersection_df_no_sliver$tract %in% intersection_type_a_b$tract,]$tract
length(tracts_left_id)
```

#### Add Single Intersections to the 2000 Table

We'll leave that data frame (intersection_type_a_b) aside and add them to the main table later with the type (c) intersections. 

#### Identify Remaining Valid Intersections  

That leaves us just a handful of tracts left.  We'll put the spatial intersections for these types (c) into their own data frame. 

```{r}
intersection_tracts_left <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tracts_left_id,]
dim(intersection_tracts_left)
```

Lets have a look at them: 

```{r}
tract_ids <- tracts_left_id

taz_overlap_ids <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]$taz

tracts1 <- tracts[tracts$tract %in% tract_ids,]
taz1 <- taz1454[taz1454$taz %in% taz_overlap_ids,]
intersection1 <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]
```

```{r}
mapview(tracts1, col.regions="green", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(taz1, col.regions="blue", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(intersection1, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light'))
```

Below we'll review a few of these intersections in more detail in order to determine which we should keep. 


We will say that this Tract is equivalent to the TAZ's that make it up. 

#### TAZ larger than Tract

Others are examples of where the TAZ is larger than the Tract. For example:

```{r}
cross_tract <- "505009"
tract_ids <- cross_tract

taz_overlap_ids <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]$taz

tracts1 <- tracts[tracts$tract %in% tract_ids,]
taz1 <- taz1454[taz1454$taz %in% taz_overlap_ids,]
intersection1 <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]

mapview(tracts1, col.regions="green", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(taz1, col.regions="blue", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(intersection1, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light'))
```

This is a type (b) and type (c) coverage. Some of the remaining tracts are like this. From here on out we'll just call the intersections valid or not. 

#### Tract Is Split by TAZ's

In some cases the Tract seems to be split by a TAZ. 

```{r}
cross_tract <- "403502"
tract_ids <- cross_tract
#blocks_df <- blocks[blocks$TRACTCE10 %in% tract_ids,]

taz_overlap_ids <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]$taz

tracts1 <- tracts[tracts$tract %in% tract_ids,]
taz1 <- taz1454[taz1454$taz %in% taz_overlap_ids,]
intersection1 <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]

mapview(tracts1, col.regions="green", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(taz1, col.regions="blue", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(intersection1, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light'))
```

We might want to develop rules for this kind of TAZ/Tract relationship in the future. For now, we will just say its equivalent to the 1 TAZ that majority covers it (972).

#### Remaining Tracts

Valid intersections include those in tracts: 511705, 614000, 061500, 061100, 131100, 410500, 313206

990100 is not valid, because it is a park/open space preserve. 980401 is not valid because its the Farallon islands.

Lets add the valid intersections to the table. 

```{r}
library(sf)
valid_intersections <- c("505009","613900","061500","511705", "614000", "061500", "061100", "131100", "410500", "313206")
intersection_type_c <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% valid_intersections,]

intersection_type_c_table <- intersection_type_c

st_geometry(intersection_type_c) <- NULL

intersection_type_c <- dplyr::select(intersection_type_c,taz,tract)

intersection_type_c <- intersection_type_c[,c('tract','taz')]

intersection_type_c$header_string <- 'rtaz'

intersection_type_c$num <- ave(intersection_type_c[['taz']], 
              intersection_type_c[['tract']], 
              FUN = seq_along)

intersection_type_c_sparse <- intersection_type_c %>% 
  tidyr::unite("header_string", 
                   header_string, 
                   num) %>% 
    tidyr::spread(header_string, taz)
```

When we build the sparse table for multiple intersections, it becomes apparent that we will have to add a column to the lookup table. In 2000, there were 5 columns, but here we've found that (for 2010) there are 6 valid intersections for 1 tract. That tract is in downtown SF, and a map of it can be found in the Appendix. 

Lets take a look at what we're adding to the updated 2000 table before we do it. We may need to reshape the columns. 

```{r}
#st_geometry(intersection_type_a_b) <- NULL

#intersection_type_a_b <- intersection_type_a_b[,c('tract','taz')]

knitr::kable(head(intersection_type_c_sparse))
knitr::kable(head(intersection_type_a_b))
knitr::kable(head(Tract_zone_2000))
```

So we need to reshape the type_a_b table and add the new column to the 2000 table. 

And rename columns to match (underscores, etc)

```{r}
intersection_type_a_b <- dplyr::rename(intersection_type_a_b, rtaz1 = taz)
intersection_type_a_b$rtaz2 <- as.integer(NA)
intersection_type_a_b$rtaz3 <- as.integer(NA)
intersection_type_a_b$rtaz4 <- as.integer(NA)
intersection_type_a_b$rtaz5 <- as.integer(NA)
intersection_type_a_b$rtaz6 <- as.integer(NA)
Tract_zone_2010$rtaz6 <- as.integer(NA)
knitr::kable(head(intersection_type_a_b))
names(Tract_zone_2010) <- names(intersection_type_a_b)
names(intersection_type_c_sparse) <- names(intersection_type_a_b)
```

Now we can bind them all together. 

```{r}
Tract_zone_2010 <- rbind(Tract_zone_2010,intersection_type_a_b,intersection_type_c_sparse)
```

#### Appendix 

Map of tract with 6 intersections. 

```{r}
cross_tract <- "061500"
tract_ids <- cross_tract
#blocks_df <- blocks[blocks$TRACTCE10 %in% tract_ids,]

taz_overlap_ids <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]$taz

tracts1 <- tracts[tracts$tract %in% tract_ids,]
taz1 <- taz1454[taz1454$taz %in% taz_overlap_ids,]
intersection1 <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]

mapview(tracts1, col.regions="green", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(taz1, col.regions="blue", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(intersection1, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light'))
```

Lets check it again. 

```{r}
number_of_equivalencies <- group_by(tract_zone_2010_dense, string) %>%
  summarize(count = n())

total <- sum(number_of_equivalencies$count)

number_of_equivalencies$percent <- round(number_of_equivalencies$count/total, digits=3)

print(number_of_equivalencies)
```

### Additional Notes

It may be useful to think about these equivalencies in terms of smaller units. When we compare a few of the TAZ's to blocks it is apparent that they were built on blocks, not tracts. 

Therefore, the more accurate "equivalence" for any given TAZ is described at the block (or perhaps block group) level, not at the tract. 

#### TAZ/Block Equivalency

In looking at these it becomes apparent that many/most of these TAZ's are equivalent to the Tracts they fall within as a group.  

It seems like the TAZ's which constitute a Tract as a group are built directly from blocks or block groups. 

For example:

```{r}
block_tract1 <- "061500"
tract_ids <- block_tract1
blocks_df <- blocks[blocks$TRACTCE10 %in% tract_ids,]

taz_overlap_ids <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]$taz

tracts1 <- tracts[tracts$tract %in% tract_ids,]
taz1 <- taz1454[taz1454$taz %in% taz_overlap_ids,]
intersection1 <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]

mapview(tracts1, col.regions="green", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(taz1, col.regions="blue", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(intersection1, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(blocks_df, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light'))
```

Or:

```{r}
block_tract1 <- "613900"
tract_ids <- block_tract1
blocks_df <- blocks[blocks$TRACTCE10 %in% tract_ids,]

taz_overlap_ids <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]$taz

tracts1 <- tracts[tracts$tract %in% tract_ids,]
taz1 <- taz1454[taz1454$taz %in% taz_overlap_ids,]
intersection1 <- intersection_df_no_sliver[intersection_df_no_sliver$tract %in% tract_ids,]

mapview(tracts1, col.regions="green", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(taz1, col.regions="blue", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(intersection1, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light')) +
  mapview(blocks_df, color="red", col.regions="red", alpha=0.8, map.types=c('Stamen.Toner.Light'))
```



